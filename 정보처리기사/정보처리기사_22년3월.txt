ㅁ 1 과목 : 소프트웨어 설계

1. 요구사항 검증(Requirements Validation)과 관련한 설명으로 틀린 것은?
  ④ 요구사항 검증 과정을 통해 모든 요구사항 문제를 발견할 수 있다.

2. UML 모델에서 한 사물의 명세가 바뀌면 다른사물에 영향을 주며, 
일반적으로 한 클래스가 다른 클래스를 오퍼레이션의 매개변수로 사용하는 경우에 나타나는 관계는?
1. 연관 관계(Association Relationship)
2. 의존 관계(Dependency Relationship) : 한 사물의 명세가 바뀌면 다른 사물에 영향을 주는 관계
3. 실체화 관계(Realization Relationship)
4. 일반화 관계(Generalization Relationship)

3. 익스트림 프로그래밍 (XP)
- 사용자의 요구사항은 언제든지 변할 수있다.
- 고객과 직접 대면하며 요구사항을 이야기하기 위해 사용자 스토리(User Story)를 활용할 수 있다.
- 기존의 방법론에 비해 실용성(Pragmatism)을 강조한 것이라고 볼 수있다

4. 소프트웨어 설계에서 사용되는 대표적인 추상화(Abstraction) 기법이 아닌 것은?
- 제어 추상화: 제어의 정확한 메커니즘을 정의하지 않고 원하는 효과를 정하는데 이용하는 방법
- 기능 추상화: 입력 자료를 출력자료로 변환하는 과정을 추상화하는 방법
- 자료 추상화: 자료와 자료에 적용될 수 있는 기능을 함께 정의함으로써 자료 객체를 구성하는 방법
- 과정추상화 : 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법
- 데이터 추상화 : 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법

5. 객체지향 설계에서 정보 은닉(Information Hiding)
다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통해 접근을 허용하는 것
클래스 외부에서 특정 정보에 접근을 막는다는 의미
정보은닉은 모듈이 독립성을 갖게 해줌으로 요구사항 등 변화에 따른 수정이 가능


6. 소프트웨어 공학에서 모델링 (Modeling)
① 개발팀이 응용문제를 이해하는 데 도움을 줄 수 있다.
③ 개발될 시스템에 대하여 여러 분야의 엔지니어들이 공통된 개념을 공유하는 데 도움을 준다.
④ 절차적인 프로그램을 위한 자료흐름도는 프로세스 위주의 모델링 방법이다


7. 요구 분석(Requirement Analysis)에 대한 설명으로 틀린 것은?
ㅁ 기능적 요구사항
- 시스템이 수행해야 하는 행위들을 구체화 한 것
- 시스템에서 제공해야 할 기능을 정의한 것
- 입력기능, 출력기능, 데이터베이스 기능, 통신 기능 
ㅁ 비기능적 요구사항
- 시스템이 가져야 하는 기능 이외의 요구사항
- 시스템의 전체적인 품질이나 고려해야 하는 제약사항 등
- 사용 용이성, 효율성, 신뢰성, 이식성, 유연성, 확장성 등
- 성능적인 면: 응답 속도, 자원 사용량 등
- 보안 측면: 침입 대응, 침입 탐지, 사용자 인증, 권한 부여 등

8. 클래스 다이어그램의 요소로 다음 설명에 해당하는 용어는? Operation
 - 클래스의 동작을 의미한다.
 - 클래스에 속하는 객체에 대하여 적용될 메서드를 정의한 것이다.
 - UML에서는 동작에 대한 인터페이스를 지칭한다고 볼 수 있다.

9. 분산 시스템을 위한 마스터-슬레이브(Master-Slave) 아키텍처
슬레이브는 마스터의 작업 요청을 처리하고, 처리된 결과를 되돌려준다. 
마스터는 슬레이브가 반환한 결과값으로부터 최종 결과값을 계산한다.

10. 요구 사항 정의 및 분석·설계의 결과물을 표현하기 위한 
모델링 과정에서 사용되는 다이어그램(Diagram)이 아닌 것은?
④ AVL Diagram : AVL 다이어그램은 이진 탐색트리에서 활용하는 다이어그램이다.

11. 객체지향의 주요 개념
② 객체는 실세계에 존재하거나 생각할 수 있는 것을 말한다.
③ 클래스는 하나 이상의 유사한 객체들을 묶어 공통된 특성을 표현한 것이다.
④ 다형성은 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질이다.

12. 사용자 인터페이스(User Interface)에 대한 설명으로 틀린 것은?
② 편리한 유지보수를 위해 개발자 중심으로 설계되어야 한다

13. GoF(Gang of Four) 디자인 패턴
① 디자인 패턴을 목적(Purpose)으로 분류할 때 생성, 구조, 행위로 분류할 수 있다. 
③ 행위 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다.
④ Singleton 패턴은 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 대한 접근 방법을 제공한다.
- Strategy 패턴 : 행위패턴, 클라이언트에 영향을 받지 않는 독립적인 알고리즘을 선택하는 패턴
- 프로토타입 패턴 : 생성패턴, 원본 객체를 복제하는 방법

14. 애자일 개발 방법론과 관련한 설명으로 틀린 것은?
② 정확한 결과 도출을 위해 계획 수립과 문서화에 중점을 둔다. 

15. 럼바우(Rumbaugh)의 객체지향 분석 기법 중 자료 흐름도(DFD)를 주로 이용하는 것은?
객체모델링 = 객체 다이어그램
동적모델링 = 상태 다이어그램
기능 모델링 = 자료흐름도

16. 순차 다이어그램(Sequence Diagram)과 관련한 설명으로 틀린 것은?
③ 동적 다이어그램보다는 정적 다이어그램에 가깝다

17. 객체지향 분석 기법과 관련한 설명
① 동적 모델링 기법이 사용될 수 있다.  
③ 데이터와 행위를 하나로 묶어 객체를 정의내리고 추상화시키는 작업이라 할 수 있다.
④ 코드 재사용에 의한 프로그램 생산성 향상 및 요구에 따른 시스템의 쉬운 변경이 가능하다.

18. 대표적으로 DOS 및 Unix 등의 운영체제에서조작을 위해 사용하던 것으로, 
정해진 명령문자열을 입력하여 시스템을 조작하는 사용자인터페이스(User Interface)는?
- CLI(Command Line Interface) : 텍스트 터미널을 통해 사용자와 컴퓨터가 명령문자열로 상호 작용하는 방식
- GUI(Graphical User Interface) : 마우스로 선택해 작업을 하는 그래픽 환경의 인터페이스
- NUI(Natural User Interface) : 사용자의 말이나 행동으로 기기를 조작하는 인터페이스
- VUI(Voice User Interface) : 사람의 음성으로 기기를 조작하는 인터페이스
- OUI(Organic User Interface) : 모든 사물과 사용자 간의 상호작용을 위한 인터페이스

19. 분산 시스템에서의 미들웨어 (Middleware)와 관련한 설명으로 틀린 것은?
④ 애플리케이션과 사용자 사이에서만 분산서비스를 제공한다.

20. 소프트웨어 아키텍처와 관련한 설명
- 파이프 필터 아키텍처에서 데이터는 파이프를 통해 단방향으로 흐르고, 필터 이동시 오버헤드가 발생될 수 있음.
② 외부에서 인식할 수 있는 특성이 담긴 소프트웨어의 골격이 되는 기본 구조로 볼수 있다. 
③ 데이터 중심 아키텍처는 공유 데이터저장소를 통해 접근자 간의 통신이 이루어지므로 각 접근자의 수정과 확장이 용이하다.  
④ 이해 관계자들의 품질 요구사항을 반영하여 품질 속성을 결정한다.


ㅁ 2과목 : 소프트웨어 개발
21. 테스트를 목적에 따라 분류했을 때,강도(Stress) 테스트에 대한 설명으로 옳은것은?
① 시스템에 고의로 실패를 유도하고 시스템이 정상적으로 복귀하는지 테스트한다. /회복
② 시스템에 과다 정보량을 부과하여 과부하 시에도 시스템이 정상적으로 작동되는지를 테스트한다.  /강도
③ 사용자의 이벤트에 시스템이 응답하는 시간,특정 시간 내에 처리하는 업무량, 사용자 요구에
 시스템이 반응하는 속도 등을 테스트한다.  / 성능
④ 부당하고 불법적인 침입을 시도하여 보안시스템이 불법적인 침투를 잘 막아내는지 테스트한다. / 안전

22. 다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 PASS 3의 결과는?
9 6 7 3 5
1> 6 7 3 5 9
2> 6 3 5 7 9
3> 3 5 6 7 9

23. 다음 그래프에서 정점 A를 선택하여 깊이우선탐색(DFS)으로 운행한 결과는?
 - 깊이 우선 탐색(Depth First Search)는 이름 그대로 최대한 깊이 탐색한 이후 
 더이상 탐색할 것이 없다면 그 이전으로 돌아가 탐색을 이어가는 것

24. 다음 설명에 부합하는 용어로 옳은 것은?
 - 소프트웨어 구조를 이루며, 다른 것들과 구별 될 수 있는 독립적인 기능을 갖는 단위
 - 하나 또는 몇개의 논리적인 기능을 갖는 단위
 - 서로 모여 하나의 완전한 프로그램으로 만들어 질 수 있다.

25. 테스트 드라이버(Test Driver)
 - 시험 대상 모듈을 호출하는 간이 소프트웨어
 - 필요에 따라 매개 변수를 전달하고 모듈을 수행한 후의 결과를 보여줄 수 있음
 - 상향식 통합 테스트에서 사용 
ㅁ 테스트 스텁(Stub) : 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구

26. 다음 중 선형 구조로만 묶인 것은?
선형구조: 리스트, 스택, 큐, 덱
비선형구조: 트리, 그래프
파일구조: 순차파일, 색인파일, 직접파일

27. 다음은 스택의 자료 삭제 알고리즘
Underflow(언더플로우) : 스택 공간에 데이터가 없는데 프로그램에서 스택에서 데이터를 꺼내려고 하는 경우, 
스택 언더플로우가 일어나며 프로그램에 오류를 발생

28. 제품 소프트웨어의 사용자 매뉴얼 작성절차로 (가)~(다)와 [보기]의 기호를 바르게 연결한 것은?
ㅁ 사용자 매뉴얼 준비 절차
작성 지침 정의 -> 사용자 매뉴얼 구성 요소 정의 -> 구성 요소별 내용 작성 -> 사용자 매뉴얼 검토

29. 순서가 A, B, C, D로 정해진 입력 자료를 스택에 입력한 후 출력한 결과로 불가능한 것은?

30. 소프트웨어 테스트에서 검증(Verification)과 확인 (Validation)에 대한 설명으로 틀린 것은?
검증 : 소프트웨어가 요구사항에 부합하게 구현되었음을 보장하는 활동
확인 : 소프트웨어가 고객의 의도에 따라 구현되었음을 보장하는 활동

31. 개별 모듈을 시험하는 것으로 모듈이 정확하게 구현되었는지, 
 예정한 기능이 제대로 수행되는지를 점검하는 것이 주요 목적인 테스트는? ②
① 통합 테스트(Integration Test) 
② 단위 테스트(Unit Test) 
③ 시스템 테스트(System Test) 
④ 인수 테스트(Acceptance Test)

32. 형상 관리의 개념과 절차에 대한 설명
ㅁ 형상 통제
- 소프트웨어 형상 변경 제안을 검토, 현재 소프트웨어 기준선(Baseline)에 반영하도록 통제
- 형상 통제가 이루어지기 위해서는 형상 통제 위원회(Configuration Control Board, CCB)의 승인을 통한 변경 통제가 이루어짐

33. 소스코드 정적 분석(Static Analysis)에 대한 설명
- 프로그램을 실행 시키지 않고 코드를 분석하는 방법
- 코드 내에 존재하는 보안 취약점, 잠재적 결함, 위험 등을 발견 가능
- 규칙과 흐름에 맞게 코드가 올바르게 작성되어 있는지 점검

34. 소프트웨어 개발 활동을 수행함에 있어서 시스템이 고장(Failure)을 일으키게 하며, 오류(Error)가 있는 경우 발생하는 것은?
 - 결함(fault)이란 오류 및 작동 실패의 원인으로서 소프트웨어 개발자의 설계와 다르게 동작하거나 제작 의도와 
다른 결과가 발생하는 것을 말합니다.

35. 코드의 간결성을 유지하기 위해 사용되는 지침
① 공백을 이용하여 실행문 그룹과 주석을 명확히 구분한다.
② 복잡한 논리식과 산술식은 괄호와 들여쓰기(Indentation)를 통해 명확히 표현한다.
③ 빈 줄을 사용하여 선언부와 구현부를 구별한다.

36. 소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은?
- 이식성(Portability): 다양한 하드웨어 환경에서도 운용 가능하도록 쉽게 수정될 수 있는 능력
- 효율성(Efficiency): 최소의 작업으로 요구되는 기능을 수행하는 정도
- 사용 용이성(Usability): 소프트웨어를 쉽게 사용할 수 있는 정도
- 정확성(Correctness): 사용자의 요구사항을 충족시키는 정도

37. 다음 중 최악의 경우 검색 효율이 가장 나쁜트리 구조는?
ㅁ 최악의 경우에서 검색 시간복잡도
-이진 탐색트리: O(n)
-AVL트리: O(log n)
-2-3트리: O(log 3n) 
-레드 블랙 트리: O(log n)

38. 다음 트리에 대한 중위 순회 운행 결과는?
전위: 중앙 노드 먼저 방문
중위: 왼쪽 노드 방문 후 중앙 노드 방문
후위: 하위 트리 노드 모드 방문 중앙 노드 방문

39. 테스트 케이스 자동 생성 도구를 이용하여 테스트 데이터를 찾아내는 방법이 아닌 것은?
ㅁ 테스트 수행 도구 : 자료 흐름도, 기능 테스트, 입력 도메인 분석, 랜덤 테스트
ㅁ 스터브(Stub)와 드라이버(Driver)는 통합 테스트 시 사용되는 것
 - 스터브(Stub)는 하향식 테스트에 사용되는 테스트용 임시 모듈
 - 드라이브(Drive)는 상향식 테스트에 사용되는 테스트 가동기

40. 저작권 관리 구성 요소 중 패키저(Packager)의 주요 역할로 옳은 것은?
- 콘텐츠 제공자: 콘텐츠를 제공하는 저작권자
- 콘텐츠 분배자: 암호화된 콘텐츠 제공
- 패키저: 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능
- 보안 컨테이너: 원본을 안전하게 유통하기 위한 전자적 보안장치
- DRM 컨트롤러: 배포된 콘텐츠의 이용 권한을 통제
- 클리어링 하우스: 소비자와 유통업자 사이에 발생하는 거래에 대해 
디지털 저작권 라이선싱을 중개하고 라이선스 발급을 수행하는 장소

ㅁ 3과목 : 데이터베이스 구축
41. 데이터베이스의 무결성 규정(Integrity Rule)과 관련한 설명으로 틀린 것은?
① 무결성 규정에는 데이터가 만족해야 될 제약 조건, 규정을 참조할 때 사용하는 식별자 등의 요소가 포함될 수 있다.     
② 무결성 규정의 대상으로는 도메인, 키, 종속성 등이 있다.     
④ 릴레이션 무결성 규정(Relation Integrity Rules)은 릴레이 션을 조작하는 과정에서의 의미적 관계(Semantic Relationship)을 명세한 것이다.

42. 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 
일련의 연산들을 의미하는 것은? ① 트랜잭션

43. 다음 두 릴레이션 Rl과 R2의 카티션 프로덕트(cartesian product) 수행 결과는?

44. 물리적 데이터베이스 설계에 대한 설명
 ① 물리적 설계의 목적은 효율적인 방법으로 데이터를 저장하는 것이다.    
 ② 트랜잭션 처리량과 응답시간, 디스크 용량 등을 고려해야 한다.     
③ 저장 레코드의 형식, 순서, 접근 경로와 같은 정보를 사용하여 설계한다.     
④ 트랜잭션의 인터페이스를 설계하며, 데이터 타입 및 데이터 타입들 간의 관계로 표현한다.
 -> 논리적 설계에서 인터페이스를 사용자의 입장에서 편리하도록 설계 

45. 다음 중 기본키는 NULL 값을 가져서는 안되며, 릴레이션 내에 오직 하나의 값만 존재해야 한다는 조건을 무엇이라 하는가?
1. 개체 무결성 : 기본키는 null 값이 될 수 없음
2. 참조 무결성 : 외래키는 참조할 수 없는 값을 가질 수 없음
3. 도메인 무결성 : 특정 속성값은 그 속성이 정의된 도메인에 속한 값이어야 함

46. SQL문에서 HAVING을 사용할 수 있는 절은? ③ GROUP BY 절

47. 관계 데이터베이스에 있어서 관계 대수 연산
1. 일반 집합 연산자
합집합
교집합
차집합
카티션 프로덕트
2. 순수 관계 연산자
셀렉트
프로젝트
조인
디비

48. 학적 테이블에서 전화번호가 Null값이 아닌 학생명을 모두 검색할 때, SQL 구문으로 옳은 것은?
③ SELECT 학생명 FROM 학적 WHERE 전화번호 IS NOT NULL;

49. 관계형 데이터베이스에서 다음 설명에 해당하는 키(Key)는?
외래키 : 한 릴레이션 내의 속성들의 집합으로 구성된 키로써, 릴레이션을 구성하는 모든 튜플에 대한 유일성은 만족시키지만 최소성은 만족시키지 못한다.

50. 데이터베이스에서 인덱스(Index)와 관련한 설명
① 인덱스의 기본 목적은 검색 성능을 최적화하는 것으로 볼 수 있다.
② B-트리 인덱스는 분기를 목적으로 하는 Branch Block을 가지고 있다.
③ BETWEEN 등 범위(Range) 검색에 활용될 수 있다.

51. 로킹 단위(Locking Granularity)에 대한 설명으로 옳은 것은
# 로킹 단위가 큼 -> 로크의 수가 적어짐 -> 병행성 수준 낮아짐, 병행 제어 기법 간단해짐
# 로킹 단위가 작음 -> 로크의 수가 많아짐

52. 관계 대수에 대한 설명
관계대수 : 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어

53. 데이터의 중복으로 인하여 관계연산을 처리할 때 예기치 못한 곤란한 현상이 발생하는 것을 무엇이라 하는가?
① 이상(Anomaly) 

54. 다음 중 SQL에서의 DDL 문이 아닌 것은
1. DDL (정의)
-CREATE (정의)
-ALTER (변경)
-DROP (삭제)
2. DML (조작)
-SELECT (검색)
-INSERT (삽입)
-DELETE (삭제)
-UPDATE (갱신)
3. DCL (제어)
-COMMIT (완료)
-ROLLBACK (되돌림)
-GRANT (권한부여)
-REVOKE (권한취소)

55. 정규화에 대한 설명으로 적절하지 않은 것은? ①
② 데이터 구조의 안정성을 최대화한다.     
③ 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지한다.     
④ 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다. 
정규화는 논리적 설계 단계에서 수행하는 작업니다.

56. 트랜잭션
Isolation(독립성,격리성)
1. 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다. 
2. 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

57. SQL의 논리 연산자
① AND
③ OR
④ NOT

58. 동시성 제어를 위한 직렬화 기법으로 트랜잭션 간의 처리 순서를 미리 정하는 방법은?
타임스탬프 기법 : 트랜젝션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임스탬프를 
부여하여 부여된 시간에 따라 트랜젝션 작업을 수행하여 트랜잭션 간의 처리순서를 미리 정하는 기법

59. 이전 단계의 정규형을 만족하면서 후보키를 통하지 않는 조인 종속(JD : Join Dependency) 제거해야 만족하는 정규형은?
- 제 5 정규형 : 제 4 정규형을 만족하며 후보키를 통하지 않는 조인 종속 제거해야 만족

60. 어떤 릴레이션 R에서 X와 Y를 각각 R의 애트리뷰트 집합의 부분 집합이라고 할 경우 애트리뷰트 X의 값 각각에 
대해 시간에 관계없이 항상 애트리뷰트 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수 종속이라고 한다. 
이 함수 종속의 표기로 옳은 것은?
X -> Y

61. 모듈 내 구성 요소들이 서로 다른 기능을 같은 시간대에 함께 실행하는 경우의 응집도(Cohesion)는?
 - Temporal Cohension(시간적 응집도)
 - Logical Cohension(논리적 응집도): 모듈 내 구성 요소들이 같은 범주에 속하는 기능끼리 묶인 경우
(ex. 새글, 불러오기, 저장하기, 다른이름으로 저장하기) 
- Coincidental Cohension(우연적 응집도): 모듈 내 구성 요소들이 뚜렷한 관계없이 묶인 경우
- Sequential Cohension(순차적 응집도): 모듈 내 구성 요소들이 이전의 명령어로부터 나온 출력결과를 그 다음 명령어의 
입력자료로 사용하는 경우(ex. 총점과 평균의 관계)

62. 오류 제어에 사용되는 자동반복 요청방식(ARQ)이 아닌 것은?
ㅁ 자동반복 요청방식(ARQ: Automatic Repeat reQuest) 
- Stop-and-Wait ARQ(정지-대기 ARQ): 송신 측이 하나의 블록을 전송한 후 수신 측에서 에러의 발생을 점검한 다음, 에러 발생 유무 신호를 보내올 때까지 기다리는 방식
- Go-Back-N ARQ: 여러 블록을 연속적으로 전송하고, 수신 측에서 부정 응답(NAK)을 보내오면 송신 측이 오류가 발생한 블록부터 모두 재 전송
- Selective-Repeat ARQ(선택적 재전송 ARQ): 여러 블록을 연속적으로 전송하고, 수신측에서 부정 응답(NAK)을 보내오면 송신 측이 오류가 발생한 블록만을 재전송
- Adaptive ARQ(적응적 ARQ): 전송 효율을 최대로 하기 위해서 데이터 블록의 길이를 채널의 상태에 따라 동적으로 변경하는 방식

























